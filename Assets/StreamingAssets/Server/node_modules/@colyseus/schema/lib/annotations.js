"use strict";
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (this && this.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.defineTypes = exports.deprecated = exports.filterChildren = exports.filter = exports.type = exports.globalContext = exports.Context = exports.hasFilter = exports.SchemaDefinition = void 0;
var Schema_1 = require("./Schema");
var ArraySchema_1 = require("./types/ArraySchema");
var MapSchema_1 = require("./types/MapSchema");
var types_1 = require("./types");
var SchemaDefinition = /** @class */ (function () {
    function SchemaDefinition() {
        //
        // TODO: use a "field" structure combining all these properties per-field.
        //
        this.indexes = {};
        this.fieldsByIndex = {};
        this.deprecated = {};
        this.descriptors = {};
    }
    SchemaDefinition.create = function (parent) {
        var definition = new SchemaDefinition();
        // support inheritance
        definition.schema = Object.assign({}, parent && parent.schema || {});
        definition.indexes = Object.assign({}, parent && parent.indexes || {});
        definition.fieldsByIndex = Object.assign({}, parent && parent.fieldsByIndex || {});
        definition.descriptors = Object.assign({}, parent && parent.descriptors || {});
        definition.deprecated = Object.assign({}, parent && parent.deprecated || {});
        return definition;
    };
    SchemaDefinition.prototype.addField = function (field, type) {
        var index = this.getNextFieldIndex();
        this.fieldsByIndex[index] = field;
        this.indexes[field] = index;
        this.schema[field] = (Array.isArray(type))
            ? { array: type[0] }
            : type;
    };
    SchemaDefinition.prototype.addFilter = function (field, cb) {
        if (!this.filters) {
            this.filters = {};
            this.indexesWithFilters = [];
        }
        this.filters[this.indexes[field]] = cb;
        this.indexesWithFilters.push(this.indexes[field]);
        return true;
    };
    SchemaDefinition.prototype.addChildrenFilter = function (field, cb) {
        var index = this.indexes[field];
        var type = this.schema[field];
        if (types_1.getType(Object.keys(type)[0])) {
            if (!this.childFilters) {
                this.childFilters = {};
            }
            this.childFilters[index] = cb;
            return true;
        }
        else {
            console.warn("@filterChildren: field '" + field + "' can't have children. Ignoring filter.");
        }
    };
    SchemaDefinition.prototype.getChildrenFilter = function (field) {
        return this.childFilters && this.childFilters[this.indexes[field]];
    };
    SchemaDefinition.prototype.getNextFieldIndex = function () {
        return Object.keys(this.schema || {}).length;
    };
    return SchemaDefinition;
}());
exports.SchemaDefinition = SchemaDefinition;
function hasFilter(klass) {
    return klass._context && klass._context.useFilters;
}
exports.hasFilter = hasFilter;
var Context = /** @class */ (function () {
    function Context() {
        this.types = {};
        this.schemas = new Map();
        this.useFilters = false;
    }
    Context.prototype.has = function (schema) {
        return this.schemas.has(schema);
    };
    Context.prototype.get = function (typeid) {
        return this.types[typeid];
    };
    Context.prototype.add = function (schema) {
        schema._typeid = this.schemas.size;
        this.types[schema._typeid] = schema;
        this.schemas.set(schema, schema._typeid);
    };
    Context.create = function (context) {
        if (context === void 0) { context = new Context; }
        return function (definition) {
            return type(definition, context);
        };
    };
    return Context;
}());
exports.Context = Context;
exports.globalContext = new Context();
/**
 * `@type()` decorator for proxies
 */
function type(type, context) {
    if (context === void 0) { context = exports.globalContext; }
    return function (target, field) {
        var constructor = target.constructor;
        constructor._context = context;
        /*
         * static schema
         */
        if (!context.has(constructor)) {
            context.add(constructor);
            // support inheritance
            constructor._definition = SchemaDefinition.create(constructor._definition);
        }
        var definition = constructor._definition;
        definition.addField(field, type);
        /**
         * skip if descriptor already exists for this field (`@deprecated()`)
         */
        if (definition.descriptors[field]) {
            return;
        }
        var isArray = ArraySchema_1.ArraySchema.is(type);
        var isMap = !isArray && MapSchema_1.MapSchema.is(type);
        // TODO: refactor me.
        // Allow abstract intermediary classes with no fields to be serialized
        // (See "should support an inheritance with a Schema type without fields" test)
        if (typeof (type) !== "string" && !Schema_1.Schema.is(type)) {
            var childType = Object.values(type)[0];
            if (typeof (childType) !== "string" && !childType._context) {
                context.add(childType);
            }
        }
        var fieldCached = "_" + field;
        definition.descriptors[fieldCached] = {
            enumerable: false,
            configurable: false,
            writable: true,
        };
        definition.descriptors[field] = {
            get: function () {
                return this[fieldCached];
            },
            set: function (value) {
                /**
                 * Create Proxy for array or map items
                 */
                // skip if value is the same as cached.
                if (value === this[fieldCached]) {
                    return;
                }
                if (value !== undefined &&
                    value !== null) {
                    // automaticallty transform Array into ArraySchema
                    if (isArray && !(value instanceof ArraySchema_1.ArraySchema)) {
                        value = new (ArraySchema_1.ArraySchema.bind.apply(ArraySchema_1.ArraySchema, __spread([void 0], value)))();
                    }
                    // automaticallty transform Map into MapSchema
                    if (isMap && !(value instanceof MapSchema_1.MapSchema)) {
                        value = new MapSchema_1.MapSchema(value);
                    }
                    // try to turn provided structure into a Proxy
                    if (value['$proxy'] === undefined) {
                        if (isMap) {
                            value = MapSchema_1.getMapProxy(value);
                        }
                        else if (isArray) {
                            value = ArraySchema_1.getArrayProxy(value);
                        }
                    }
                    // flag the change for encoding.
                    this.$changes.change(field);
                    //
                    // call setParent() recursively for this and its child
                    // structures.
                    //
                    if (value['$changes']) {
                        value['$changes'].setParent(this, this.$changes.root, this._definition.indexes[field]);
                    }
                }
                else {
                    //
                    // Setting a field to `null` or `undefined` will delete it.
                    //
                    this.$changes.delete(field);
                }
                this[fieldCached] = value;
            },
            enumerable: true,
            configurable: true
        };
    };
}
exports.type = type;
/**
 * `@filter()` decorator for defining data filters per client
 */
function filter(cb) {
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        if (definition.addFilter(field, cb)) {
            constructor._context.useFilters = true;
        }
    };
}
exports.filter = filter;
function filterChildren(cb) {
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        if (definition.addChildrenFilter(field, cb)) {
            constructor._context.useFilters = true;
        }
    };
}
exports.filterChildren = filterChildren;
/**
 * `@deprecated()` flag a field as deprecated.
 * The previous `@type()` annotation should remain along with this one.
 */
function deprecated(throws, context) {
    if (throws === void 0) { throws = true; }
    if (context === void 0) { context = exports.globalContext; }
    return function (target, field) {
        var constructor = target.constructor;
        var definition = constructor._definition;
        definition.deprecated[field] = true;
        if (throws) {
            definition.descriptors[field] = {
                get: function () { throw new Error(field + " is deprecated."); },
                set: function (value) { },
                enumerable: false,
                configurable: true
            };
        }
    };
}
exports.deprecated = deprecated;
function defineTypes(target, fields, context) {
    if (context === void 0) { context = target._context || exports.globalContext; }
    for (var field in fields) {
        type(fields[field], context)(target.prototype, field);
    }
    return target;
}
exports.defineTypes = defineTypes;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ub3RhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi9zcmMvYW5ub3RhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFDQSxtQ0FBa0M7QUFDbEMsbURBQWlFO0FBQ2pFLCtDQUEyRDtBQUMzRCxpQ0FBa0M7QUFnRGxDO0lBQUE7UUFHSSxFQUFFO1FBQ0YsMEVBQTBFO1FBQzFFLEVBQUU7UUFFRixZQUFPLEdBQWdDLEVBQUUsQ0FBQztRQUMxQyxrQkFBYSxHQUFnQyxFQUFFLENBQUM7UUFNaEQsZUFBVSxHQUFpQyxFQUFFLENBQUM7UUFDOUMsZ0JBQVcsR0FBMEMsRUFBRSxDQUFDO0lBd0Q1RCxDQUFDO0lBdERVLHVCQUFNLEdBQWIsVUFBYyxNQUF5QjtRQUNuQyxJQUFNLFVBQVUsR0FBRyxJQUFJLGdCQUFnQixFQUFFLENBQUM7UUFFMUMsc0JBQXNCO1FBQ3RCLFVBQVUsQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUM7UUFDckUsVUFBVSxDQUFDLE9BQU8sR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLE9BQU8sSUFBSSxFQUFFLENBQUMsQ0FBQztRQUN2RSxVQUFVLENBQUMsYUFBYSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsRUFBRSxFQUFFLE1BQU0sSUFBSSxNQUFNLENBQUMsYUFBYSxJQUFJLEVBQUUsQ0FBQyxDQUFDO1FBQ25GLFVBQVUsQ0FBQyxXQUFXLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEVBQUUsTUFBTSxJQUFJLE1BQU0sQ0FBQyxXQUFXLElBQUksRUFBRSxDQUFDLENBQUM7UUFDL0UsVUFBVSxDQUFDLFVBQVUsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLEVBQUUsRUFBRSxNQUFNLElBQUksTUFBTSxDQUFDLFVBQVUsSUFBSSxFQUFFLENBQUMsQ0FBQztRQUU3RSxPQUFPLFVBQVUsQ0FBQztJQUN0QixDQUFDO0lBRUQsbUNBQVEsR0FBUixVQUFTLEtBQWEsRUFBRSxJQUFvQjtRQUN4QyxJQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsaUJBQWlCLEVBQUUsQ0FBQztRQUN2QyxJQUFJLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUNsQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxHQUFHLEtBQUssQ0FBQztRQUM1QixJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUN0QyxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFO1lBQ3BCLENBQUMsQ0FBQyxJQUFJLENBQUM7SUFDZixDQUFDO0lBRUQsb0NBQVMsR0FBVCxVQUFVLEtBQWEsRUFBRSxFQUFrQjtRQUN2QyxJQUFJLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRTtZQUNmLElBQUksQ0FBQyxPQUFPLEdBQUcsRUFBRSxDQUFDO1lBQ2xCLElBQUksQ0FBQyxrQkFBa0IsR0FBRyxFQUFFLENBQUM7U0FDaEM7UUFDRCxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdkMsSUFBSSxDQUFDLGtCQUFrQixDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDbEQsT0FBTyxJQUFJLENBQUM7SUFDaEIsQ0FBQztJQUVELDRDQUFpQixHQUFqQixVQUFrQixLQUFhLEVBQUUsRUFBMEI7UUFDdkQsSUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQztRQUNsQyxJQUFNLElBQUksR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBRWhDLElBQUksZUFBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsRUFBRTtZQUMvQixJQUFJLENBQUMsSUFBSSxDQUFDLFlBQVksRUFBRTtnQkFBRSxJQUFJLENBQUMsWUFBWSxHQUFHLEVBQUUsQ0FBQzthQUFFO1lBRW5ELElBQUksQ0FBQyxZQUFZLENBQUMsS0FBSyxDQUFDLEdBQUcsRUFBRSxDQUFDO1lBQzlCLE9BQU8sSUFBSSxDQUFDO1NBRWY7YUFBTTtZQUNILE9BQU8sQ0FBQyxJQUFJLENBQUMsNkJBQTJCLEtBQUssNENBQXlDLENBQUMsQ0FBQztTQUMzRjtJQUNMLENBQUM7SUFFRCw0Q0FBaUIsR0FBakIsVUFBa0IsS0FBYTtRQUMzQixPQUFPLElBQUksQ0FBQyxZQUFZLElBQUksSUFBSSxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUM7SUFDdkUsQ0FBQztJQUVELDRDQUFpQixHQUFqQjtRQUNJLE9BQU8sTUFBTSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sQ0FBQztJQUNqRCxDQUFDO0lBQ0wsdUJBQUM7QUFBRCxDQUFDLEFBdkVELElBdUVDO0FBdkVZLDRDQUFnQjtBQXlFN0IsU0FBZ0IsU0FBUyxDQUFDLEtBQW9CO0lBQzFDLE9BQU8sS0FBSyxDQUFDLFFBQVEsSUFBSSxLQUFLLENBQUMsUUFBUSxDQUFDLFVBQVUsQ0FBQztBQUN2RCxDQUFDO0FBRkQsOEJBRUM7QUFPRDtJQUFBO1FBQ0ksVUFBSyxHQUFrQyxFQUFFLENBQUM7UUFDMUMsWUFBTyxHQUFHLElBQUksR0FBRyxFQUF5QixDQUFDO1FBQzNDLGVBQVUsR0FBRyxLQUFLLENBQUM7SUFxQnZCLENBQUM7SUFuQkcscUJBQUcsR0FBSCxVQUFJLE1BQXFCO1FBQ3JCLE9BQU8sSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDcEMsQ0FBQztJQUVELHFCQUFHLEdBQUgsVUFBSSxNQUFjO1FBQ2QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzlCLENBQUM7SUFFRCxxQkFBRyxHQUFILFVBQUksTUFBcUI7UUFDckIsTUFBTSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQztRQUNuQyxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsR0FBRyxNQUFNLENBQUM7UUFDcEMsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsTUFBTSxFQUFFLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztJQUM3QyxDQUFDO0lBRU0sY0FBTSxHQUFiLFVBQWMsT0FBOEI7UUFBOUIsd0JBQUEsRUFBQSxjQUF1QixPQUFPO1FBQ3hDLE9BQU8sVUFBVSxVQUEwQjtZQUN2QyxPQUFPLElBQUksQ0FBQyxVQUFVLEVBQUUsT0FBTyxDQUFDLENBQUM7UUFDckMsQ0FBQyxDQUFBO0lBQ0wsQ0FBQztJQUNMLGNBQUM7QUFBRCxDQUFDLEFBeEJELElBd0JDO0FBeEJZLDBCQUFPO0FBMEJQLFFBQUEsYUFBYSxHQUFHLElBQUksT0FBTyxFQUFFLENBQUM7QUFFM0M7O0dBRUc7QUFDSCxTQUFnQixJQUFJLENBQUUsSUFBb0IsRUFBRSxPQUFnQztJQUFoQyx3QkFBQSxFQUFBLFVBQW1CLHFCQUFhO0lBQ3hFLE9BQU8sVUFBVSxNQUFxQixFQUFFLEtBQWE7UUFDakQsSUFBTSxXQUFXLEdBQUcsTUFBTSxDQUFDLFdBQTRCLENBQUM7UUFDeEQsV0FBVyxDQUFDLFFBQVEsR0FBRyxPQUFPLENBQUM7UUFFL0I7O1dBRUc7UUFDSCxJQUFJLENBQUMsT0FBTyxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsRUFBRTtZQUMzQixPQUFPLENBQUMsR0FBRyxDQUFDLFdBQVcsQ0FBQyxDQUFDO1lBRXpCLHNCQUFzQjtZQUN0QixXQUFXLENBQUMsV0FBVyxHQUFHLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDOUU7UUFFRCxJQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDO1FBQzNDLFVBQVUsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxDQUFDO1FBRWpDOztXQUVHO1FBQ0gsSUFBSSxVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQUUsT0FBTztTQUFFO1FBRTlDLElBQU0sT0FBTyxHQUFHLHlCQUFXLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3JDLElBQU0sS0FBSyxHQUFHLENBQUMsT0FBTyxJQUFJLHFCQUFTLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBRTdDLHFCQUFxQjtRQUNyQixzRUFBc0U7UUFDdEUsK0VBQStFO1FBQy9FLElBQUksT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLFFBQVEsSUFBSSxDQUFDLGVBQU0sQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEVBQUU7WUFDaEQsSUFBTSxTQUFTLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUN6QyxJQUFJLE9BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxRQUFRLElBQUksQ0FBQyxTQUFTLENBQUMsUUFBUSxFQUFFO2dCQUN2RCxPQUFPLENBQUMsR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2FBQzFCO1NBQ0o7UUFFRCxJQUFNLFdBQVcsR0FBRyxNQUFJLEtBQU8sQ0FBQztRQUVoQyxVQUFVLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxHQUFHO1lBQ2xDLFVBQVUsRUFBRSxLQUFLO1lBQ2pCLFlBQVksRUFBRSxLQUFLO1lBQ25CLFFBQVEsRUFBRSxJQUFJO1NBQ2pCLENBQUM7UUFFRixVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHO1lBQzVCLEdBQUcsRUFBRTtnQkFDRCxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM3QixDQUFDO1lBRUQsR0FBRyxFQUFFLFVBQXdCLEtBQVU7Z0JBQ25DOzttQkFFRztnQkFFSCx1Q0FBdUM7Z0JBQ3ZDLElBQUksS0FBSyxLQUFLLElBQUksQ0FBQyxXQUFXLENBQUMsRUFBRTtvQkFDN0IsT0FBTztpQkFDVjtnQkFFRCxJQUNJLEtBQUssS0FBSyxTQUFTO29CQUNuQixLQUFLLEtBQUssSUFBSSxFQUNoQjtvQkFDRSxrREFBa0Q7b0JBQ2xELElBQUksT0FBTyxJQUFJLENBQUMsQ0FBQyxLQUFLLFlBQVkseUJBQVcsQ0FBQyxFQUFFO3dCQUM1QyxLQUFLLFFBQU8seUJBQVcsWUFBWCx5QkFBVyxxQkFBSSxLQUFLLEtBQUMsQ0FBQztxQkFDckM7b0JBRUQsOENBQThDO29CQUM5QyxJQUFJLEtBQUssSUFBSSxDQUFDLENBQUMsS0FBSyxZQUFZLHFCQUFTLENBQUMsRUFBRTt3QkFDeEMsS0FBSyxHQUFHLElBQUkscUJBQVMsQ0FBQyxLQUFLLENBQUMsQ0FBQztxQkFDaEM7b0JBRUQsOENBQThDO29CQUM5QyxJQUFJLEtBQUssQ0FBQyxRQUFRLENBQUMsS0FBSyxTQUFTLEVBQUU7d0JBQy9CLElBQUksS0FBSyxFQUFFOzRCQUNQLEtBQUssR0FBRyx1QkFBVyxDQUFDLEtBQUssQ0FBQyxDQUFDO3lCQUU5Qjs2QkFBTSxJQUFJLE9BQU8sRUFBRTs0QkFDaEIsS0FBSyxHQUFHLDJCQUFhLENBQUMsS0FBSyxDQUFDLENBQUM7eUJBQ2hDO3FCQUNKO29CQUVELGdDQUFnQztvQkFDaEMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7b0JBRTVCLEVBQUU7b0JBQ0Ysc0RBQXNEO29CQUN0RCxjQUFjO29CQUNkLEVBQUU7b0JBQ0YsSUFBSSxLQUFLLENBQUMsVUFBVSxDQUFDLEVBQUU7d0JBQ2xCLEtBQUssQ0FBQyxVQUFVLENBQWdCLENBQUMsU0FBUyxDQUN2QyxJQUFJLEVBQ0osSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLEVBQ2xCLElBQUksQ0FBQyxXQUFXLENBQUMsT0FBTyxDQUFDLEtBQUssQ0FBQyxDQUNsQyxDQUFDO3FCQUNMO2lCQUVKO3FCQUFNO29CQUNILEVBQUU7b0JBQ0YsMkRBQTJEO29CQUMzRCxFQUFFO29CQUNGLElBQUksQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO2lCQUMvQjtnQkFFRCxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsS0FBSyxDQUFDO1lBQzlCLENBQUM7WUFFRCxVQUFVLEVBQUUsSUFBSTtZQUNoQixZQUFZLEVBQUUsSUFBSTtTQUNyQixDQUFDO0lBQ04sQ0FBQyxDQUFBO0FBQ0wsQ0FBQztBQWhIRCxvQkFnSEM7QUFFRDs7R0FFRztBQUVILFNBQWdCLE1BQU0sQ0FBd0MsRUFBMkI7SUFDckYsT0FBTyxVQUFVLE1BQVcsRUFBRSxLQUFhO1FBQ3ZDLElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUE0QixDQUFDO1FBQ3hELElBQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUM7UUFFM0MsSUFBSSxVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRTtZQUNqQyxXQUFXLENBQUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDMUM7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBVEQsd0JBU0M7QUFFRCxTQUFnQixjQUFjLENBQTJDLEVBQXNDO0lBQzNHLE9BQU8sVUFBVSxNQUFXLEVBQUUsS0FBYTtRQUN2QyxJQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsV0FBNEIsQ0FBQztRQUN4RCxJQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsV0FBVyxDQUFDO1FBQzNDLElBQUksVUFBVSxDQUFDLGlCQUFpQixDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsRUFBRTtZQUN6QyxXQUFXLENBQUMsUUFBUSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7U0FDMUM7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBUkQsd0NBUUM7QUFHRDs7O0dBR0c7QUFFSCxTQUFnQixVQUFVLENBQUMsTUFBc0IsRUFBRSxPQUFnQztJQUF4RCx1QkFBQSxFQUFBLGFBQXNCO0lBQUUsd0JBQUEsRUFBQSxVQUFtQixxQkFBYTtJQUMvRSxPQUFPLFVBQVUsTUFBcUIsRUFBRSxLQUFhO1FBQ2pELElBQU0sV0FBVyxHQUFHLE1BQU0sQ0FBQyxXQUE0QixDQUFDO1FBQ3hELElBQU0sVUFBVSxHQUFHLFdBQVcsQ0FBQyxXQUFXLENBQUM7UUFFM0MsVUFBVSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsR0FBRyxJQUFJLENBQUM7UUFFcEMsSUFBSSxNQUFNLEVBQUU7WUFDUixVQUFVLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxHQUFHO2dCQUM1QixHQUFHLEVBQUUsY0FBYyxNQUFNLElBQUksS0FBSyxDQUFJLEtBQUssb0JBQWlCLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBQ2hFLEdBQUcsRUFBRSxVQUF3QixLQUFVLElBQXNELENBQUM7Z0JBQzlGLFVBQVUsRUFBRSxLQUFLO2dCQUNqQixZQUFZLEVBQUUsSUFBSTthQUNyQixDQUFDO1NBQ0w7SUFDTCxDQUFDLENBQUE7QUFDTCxDQUFDO0FBaEJELGdDQWdCQztBQUVELFNBQWdCLFdBQVcsQ0FDdkIsTUFBcUIsRUFDckIsTUFBOEMsRUFDOUMsT0FBbUQ7SUFBbkQsd0JBQUEsRUFBQSxVQUFtQixNQUFNLENBQUMsUUFBUSxJQUFJLHFCQUFhO0lBRW5ELEtBQUssSUFBSSxLQUFLLElBQUksTUFBTSxFQUFFO1FBQ3RCLElBQUksQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsT0FBTyxDQUFDLENBQUMsTUFBTSxDQUFDLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztLQUN6RDtJQUNELE9BQU8sTUFBTSxDQUFDO0FBQ2xCLENBQUM7QUFURCxrQ0FTQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IENoYW5nZVRyZWUgfSBmcm9tICcuL2NoYW5nZXMvQ2hhbmdlVHJlZSc7XG5pbXBvcnQgeyBTY2hlbWEgfSBmcm9tICcuL1NjaGVtYSc7XG5pbXBvcnQgeyBBcnJheVNjaGVtYSwgZ2V0QXJyYXlQcm94eSB9IGZyb20gJy4vdHlwZXMvQXJyYXlTY2hlbWEnO1xuaW1wb3J0IHsgTWFwU2NoZW1hLCBnZXRNYXBQcm94eSB9IGZyb20gJy4vdHlwZXMvTWFwU2NoZW1hJztcbmltcG9ydCB7IGdldFR5cGUgfSBmcm9tICcuL3R5cGVzJztcblxuLyoqXG4gKiBEYXRhIHR5cGVzXG4gKi9cbmV4cG9ydCB0eXBlIFByaW1pdGl2ZVR5cGUgPVxuICAgIFwic3RyaW5nXCIgfFxuICAgIFwibnVtYmVyXCIgfFxuICAgIFwiYm9vbGVhblwiIHxcbiAgICBcImludDhcIiB8XG4gICAgXCJ1aW50OFwiIHxcbiAgICBcImludDE2XCIgfFxuICAgIFwidWludDE2XCIgfFxuICAgIFwiaW50MzJcIiB8XG4gICAgXCJ1aW50MzJcIiB8XG4gICAgXCJpbnQ2NFwiIHxcbiAgICBcInVpbnQ2NFwiIHxcbiAgICBcImZsb2F0MzJcIiB8XG4gICAgXCJmbG9hdDY0XCIgfFxuICAgIHR5cGVvZiBTY2hlbWE7XG5cbmV4cG9ydCB0eXBlIERlZmluaXRpb25UeXBlID0gUHJpbWl0aXZlVHlwZVxuICAgIHwgUHJpbWl0aXZlVHlwZVtdXG4gICAgfCB7IGFycmF5OiBQcmltaXRpdmVUeXBlIH1cbiAgICB8IHsgbWFwOiBQcmltaXRpdmVUeXBlIH1cbiAgICB8IHsgY29sbGVjdGlvbjogUHJpbWl0aXZlVHlwZSB9XG4gICAgfCB7IHNldDogUHJpbWl0aXZlVHlwZSB9O1xuXG5leHBvcnQgdHlwZSBEZWZpbml0aW9uID0geyBbZmllbGQ6IHN0cmluZ106IERlZmluaXRpb25UeXBlIH07XG5leHBvcnQgdHlwZSBGaWx0ZXJDYWxsYmFjazxcbiAgICBUIGV4dGVuZHMgU2NoZW1hID0gYW55LFxuICAgIFYgPSBhbnksXG4gICAgUiBleHRlbmRzIFNjaGVtYSA9IGFueVxuPiA9IChcbiAgICAoKHRoaXM6IFQsIGNsaWVudDogQ2xpZW50LCB2YWx1ZTogVikgPT4gYm9vbGVhbikgfFxuICAgICgodGhpczogVCwgY2xpZW50OiBDbGllbnQsIHZhbHVlOiBWLCByb290OiBSKSA9PiBib29sZWFuKVxuKTtcblxuZXhwb3J0IHR5cGUgRmlsdGVyQ2hpbGRyZW5DYWxsYmFjazxcbiAgICBUIGV4dGVuZHMgU2NoZW1hID0gYW55LFxuICAgIEsgPSBhbnksXG4gICAgViA9IGFueSxcbiAgICBSIGV4dGVuZHMgU2NoZW1hID0gYW55XG4+ID0gKFxuICAgICgodGhpczogVCwgY2xpZW50OiBDbGllbnQsIGtleTogSywgdmFsdWU6IFYpID0+IGJvb2xlYW4pIHxcbiAgICAoKHRoaXM6IFQsIGNsaWVudDogQ2xpZW50LCBrZXk6IEssIHZhbHVlOiBWLCByb290OiBSKSA9PiBib29sZWFuKVxuKVxuXG5leHBvcnQgY2xhc3MgU2NoZW1hRGVmaW5pdGlvbiB7XG4gICAgc2NoZW1hOiBEZWZpbml0aW9uO1xuXG4gICAgLy9cbiAgICAvLyBUT0RPOiB1c2UgYSBcImZpZWxkXCIgc3RydWN0dXJlIGNvbWJpbmluZyBhbGwgdGhlc2UgcHJvcGVydGllcyBwZXItZmllbGQuXG4gICAgLy9cblxuICAgIGluZGV4ZXM6IHsgW2ZpZWxkOiBzdHJpbmddOiBudW1iZXIgfSA9IHt9O1xuICAgIGZpZWxkc0J5SW5kZXg6IHsgW2luZGV4OiBudW1iZXJdOiBzdHJpbmcgfSA9IHt9O1xuXG4gICAgZmlsdGVyczogeyBbZmllbGQ6IHN0cmluZ106IEZpbHRlckNhbGxiYWNrIH07XG4gICAgaW5kZXhlc1dpdGhGaWx0ZXJzOiBudW1iZXJbXTtcbiAgICBjaGlsZEZpbHRlcnM6IHsgW2ZpZWxkOiBzdHJpbmddOiBGaWx0ZXJDaGlsZHJlbkNhbGxiYWNrIH07IC8vIGNoaWxkRmlsdGVycyBhcmUgdXNlZCBvbiBNYXAsIEFycmF5LCBTZXQgaXRlbXMuXG5cbiAgICBkZXByZWNhdGVkOiB7IFtmaWVsZDogc3RyaW5nXTogYm9vbGVhbiB9ID0ge307XG4gICAgZGVzY3JpcHRvcnM6IFByb3BlcnR5RGVzY3JpcHRvck1hcCAmIFRoaXNUeXBlPGFueT4gPSB7fTtcblxuICAgIHN0YXRpYyBjcmVhdGUocGFyZW50PzogU2NoZW1hRGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gbmV3IFNjaGVtYURlZmluaXRpb24oKTtcblxuICAgICAgICAvLyBzdXBwb3J0IGluaGVyaXRhbmNlXG4gICAgICAgIGRlZmluaXRpb24uc2NoZW1hID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50ICYmIHBhcmVudC5zY2hlbWEgfHwge30pO1xuICAgICAgICBkZWZpbml0aW9uLmluZGV4ZXMgPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmluZGV4ZXMgfHwge30pO1xuICAgICAgICBkZWZpbml0aW9uLmZpZWxkc0J5SW5kZXggPSBPYmplY3QuYXNzaWduKHt9LCBwYXJlbnQgJiYgcGFyZW50LmZpZWxkc0J5SW5kZXggfHwge30pO1xuICAgICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzID0gT2JqZWN0LmFzc2lnbih7fSwgcGFyZW50ICYmIHBhcmVudC5kZXNjcmlwdG9ycyB8fCB7fSk7XG4gICAgICAgIGRlZmluaXRpb24uZGVwcmVjYXRlZCA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmVudCAmJiBwYXJlbnQuZGVwcmVjYXRlZCB8fCB7fSk7XG5cbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb247XG4gICAgfVxuXG4gICAgYWRkRmllbGQoZmllbGQ6IHN0cmluZywgdHlwZTogRGVmaW5pdGlvblR5cGUpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmdldE5leHRGaWVsZEluZGV4KCk7XG4gICAgICAgIHRoaXMuZmllbGRzQnlJbmRleFtpbmRleF0gPSBmaWVsZDtcbiAgICAgICAgdGhpcy5pbmRleGVzW2ZpZWxkXSA9IGluZGV4O1xuICAgICAgICB0aGlzLnNjaGVtYVtmaWVsZF0gPSAoQXJyYXkuaXNBcnJheSh0eXBlKSlcbiAgICAgICAgICAgID8geyBhcnJheTogdHlwZVswXSB9XG4gICAgICAgICAgICA6IHR5cGU7XG4gICAgfVxuXG4gICAgYWRkRmlsdGVyKGZpZWxkOiBzdHJpbmcsIGNiOiBGaWx0ZXJDYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuZmlsdGVycykge1xuICAgICAgICAgICAgdGhpcy5maWx0ZXJzID0ge307XG4gICAgICAgICAgICB0aGlzLmluZGV4ZXNXaXRoRmlsdGVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmlsdGVyc1t0aGlzLmluZGV4ZXNbZmllbGRdXSA9IGNiO1xuICAgICAgICB0aGlzLmluZGV4ZXNXaXRoRmlsdGVycy5wdXNoKHRoaXMuaW5kZXhlc1tmaWVsZF0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBhZGRDaGlsZHJlbkZpbHRlcihmaWVsZDogc3RyaW5nLCBjYjogRmlsdGVyQ2hpbGRyZW5DYWxsYmFjaykge1xuICAgICAgICBjb25zdCBpbmRleCA9IHRoaXMuaW5kZXhlc1tmaWVsZF07XG4gICAgICAgIGNvbnN0IHR5cGUgPSB0aGlzLnNjaGVtYVtmaWVsZF07XG5cbiAgICAgICAgaWYgKGdldFR5cGUoT2JqZWN0LmtleXModHlwZSlbMF0pKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2hpbGRGaWx0ZXJzKSB7IHRoaXMuY2hpbGRGaWx0ZXJzID0ge307IH1cblxuICAgICAgICAgICAgdGhpcy5jaGlsZEZpbHRlcnNbaW5kZXhdID0gY2I7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGBAZmlsdGVyQ2hpbGRyZW46IGZpZWxkICcke2ZpZWxkfScgY2FuJ3QgaGF2ZSBjaGlsZHJlbi4gSWdub3JpbmcgZmlsdGVyLmApO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2V0Q2hpbGRyZW5GaWx0ZXIoZmllbGQ6IHN0cmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5jaGlsZEZpbHRlcnMgJiYgdGhpcy5jaGlsZEZpbHRlcnNbdGhpcy5pbmRleGVzW2ZpZWxkXV07XG4gICAgfVxuXG4gICAgZ2V0TmV4dEZpZWxkSW5kZXgoKSB7XG4gICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNjaGVtYSB8fCB7fSkubGVuZ3RoO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhhc0ZpbHRlcihrbGFzczogdHlwZW9mIFNjaGVtYSkge1xuICAgIHJldHVybiBrbGFzcy5fY29udGV4dCAmJiBrbGFzcy5fY29udGV4dC51c2VGaWx0ZXJzO1xufVxuXG4vLyBDb2x5c2V1cyBpbnRlZ3JhdGlvblxuZXhwb3J0IHR5cGUgQ2xpZW50ID0ge1xuICAgIHNlc3Npb25JZDogc3RyaW5nLFxufSAmIGFueTtcblxuZXhwb3J0IGNsYXNzIENvbnRleHQge1xuICAgIHR5cGVzOiB7W2lkOiBudW1iZXJdOiB0eXBlb2YgU2NoZW1hfSA9IHt9O1xuICAgIHNjaGVtYXMgPSBuZXcgTWFwPHR5cGVvZiBTY2hlbWEsIG51bWJlcj4oKTtcbiAgICB1c2VGaWx0ZXJzID0gZmFsc2U7XG5cbiAgICBoYXMoc2NoZW1hOiB0eXBlb2YgU2NoZW1hKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNjaGVtYXMuaGFzKHNjaGVtYSk7XG4gICAgfVxuXG4gICAgZ2V0KHR5cGVpZDogbnVtYmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnR5cGVzW3R5cGVpZF07XG4gICAgfVxuXG4gICAgYWRkKHNjaGVtYTogdHlwZW9mIFNjaGVtYSkge1xuICAgICAgICBzY2hlbWEuX3R5cGVpZCA9IHRoaXMuc2NoZW1hcy5zaXplO1xuICAgICAgICB0aGlzLnR5cGVzW3NjaGVtYS5fdHlwZWlkXSA9IHNjaGVtYTtcbiAgICAgICAgdGhpcy5zY2hlbWFzLnNldChzY2hlbWEsIHNjaGVtYS5fdHlwZWlkKTtcbiAgICB9XG5cbiAgICBzdGF0aWMgY3JlYXRlKGNvbnRleHQ6IENvbnRleHQgPSBuZXcgQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGRlZmluaXRpb246IERlZmluaXRpb25UeXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZShkZWZpbml0aW9uLCBjb250ZXh0KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IGdsb2JhbENvbnRleHQgPSBuZXcgQ29udGV4dCgpO1xuXG4vKipcbiAqIGBAdHlwZSgpYCBkZWNvcmF0b3IgZm9yIHByb3hpZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHR5cGUgKHR5cGU6IERlZmluaXRpb25UeXBlLCBjb250ZXh0OiBDb250ZXh0ID0gZ2xvYmFsQ29udGV4dCk6IFByb3BlcnR5RGVjb3JhdG9yIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldDogdHlwZW9mIFNjaGVtYSwgZmllbGQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBjb25zdHJ1Y3RvciA9IHRhcmdldC5jb25zdHJ1Y3RvciBhcyB0eXBlb2YgU2NoZW1hO1xuICAgICAgICBjb25zdHJ1Y3Rvci5fY29udGV4dCA9IGNvbnRleHQ7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogc3RhdGljIHNjaGVtYVxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKCFjb250ZXh0Lmhhcyhjb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIGNvbnRleHQuYWRkKGNvbnN0cnVjdG9yKTtcblxuICAgICAgICAgICAgLy8gc3VwcG9ydCBpbmhlcml0YW5jZVxuICAgICAgICAgICAgY29uc3RydWN0b3IuX2RlZmluaXRpb24gPSBTY2hlbWFEZWZpbml0aW9uLmNyZWF0ZShjb25zdHJ1Y3Rvci5fZGVmaW5pdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkZWZpbml0aW9uID0gY29uc3RydWN0b3IuX2RlZmluaXRpb247XG4gICAgICAgIGRlZmluaXRpb24uYWRkRmllbGQoZmllbGQsIHR5cGUpO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBza2lwIGlmIGRlc2NyaXB0b3IgYWxyZWFkeSBleGlzdHMgZm9yIHRoaXMgZmllbGQgKGBAZGVwcmVjYXRlZCgpYClcbiAgICAgICAgICovXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkXSkgeyByZXR1cm47IH1cblxuICAgICAgICBjb25zdCBpc0FycmF5ID0gQXJyYXlTY2hlbWEuaXModHlwZSk7XG4gICAgICAgIGNvbnN0IGlzTWFwID0gIWlzQXJyYXkgJiYgTWFwU2NoZW1hLmlzKHR5cGUpO1xuXG4gICAgICAgIC8vIFRPRE86IHJlZmFjdG9yIG1lLlxuICAgICAgICAvLyBBbGxvdyBhYnN0cmFjdCBpbnRlcm1lZGlhcnkgY2xhc3NlcyB3aXRoIG5vIGZpZWxkcyB0byBiZSBzZXJpYWxpemVkXG4gICAgICAgIC8vIChTZWUgXCJzaG91bGQgc3VwcG9ydCBhbiBpbmhlcml0YW5jZSB3aXRoIGEgU2NoZW1hIHR5cGUgd2l0aG91dCBmaWVsZHNcIiB0ZXN0KVxuICAgICAgICBpZiAodHlwZW9mICh0eXBlKSAhPT0gXCJzdHJpbmdcIiAmJiAhU2NoZW1hLmlzKHR5cGUpKSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFR5cGUgPSBPYmplY3QudmFsdWVzKHR5cGUpWzBdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZihjaGlsZFR5cGUpICE9PSBcInN0cmluZ1wiICYmICFjaGlsZFR5cGUuX2NvbnRleHQpIHtcbiAgICAgICAgICAgICAgICBjb250ZXh0LmFkZChjaGlsZFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmllbGRDYWNoZWQgPSBgXyR7ZmllbGR9YDtcblxuICAgICAgICBkZWZpbml0aW9uLmRlc2NyaXB0b3JzW2ZpZWxkQ2FjaGVkXSA9IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICB9O1xuXG4gICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdID0ge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXNbZmllbGRDYWNoZWRdO1xuICAgICAgICAgICAgfSxcblxuICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhpczogU2NoZW1hLCB2YWx1ZTogYW55KSB7XG4gICAgICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgICAgICogQ3JlYXRlIFByb3h5IGZvciBhcnJheSBvciBtYXAgaXRlbXNcbiAgICAgICAgICAgICAgICAgKi9cblxuICAgICAgICAgICAgICAgIC8vIHNraXAgaWYgdmFsdWUgaXMgdGhlIHNhbWUgYXMgY2FjaGVkLlxuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gdGhpc1tmaWVsZENhY2hlZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSAhPT0gbnVsbFxuICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gQXJyYXkgaW50byBBcnJheVNjaGVtYVxuICAgICAgICAgICAgICAgICAgICBpZiAoaXNBcnJheSAmJiAhKHZhbHVlIGluc3RhbmNlb2YgQXJyYXlTY2hlbWEpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG5ldyBBcnJheVNjaGVtYSguLi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBhdXRvbWF0aWNhbGx0eSB0cmFuc2Zvcm0gTWFwIGludG8gTWFwU2NoZW1hXG4gICAgICAgICAgICAgICAgICAgIGlmIChpc01hcCAmJiAhKHZhbHVlIGluc3RhbmNlb2YgTWFwU2NoZW1hKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBuZXcgTWFwU2NoZW1hKHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRyeSB0byB0dXJuIHByb3ZpZGVkIHN0cnVjdHVyZSBpbnRvIGEgUHJveHlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckcHJveHknXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNNYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IGdldE1hcFByb3h5KHZhbHVlKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBnZXRBcnJheVByb3h5KHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZsYWcgdGhlIGNoYW5nZSBmb3IgZW5jb2RpbmcuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJGNoYW5nZXMuY2hhbmdlKGZpZWxkKTtcblxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsIHNldFBhcmVudCgpIHJlY3Vyc2l2ZWx5IGZvciB0aGlzIGFuZCBpdHMgY2hpbGRcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RydWN0dXJlcy5cbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlWyckY2hhbmdlcyddKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAodmFsdWVbJyRjaGFuZ2VzJ10gYXMgQ2hhbmdlVHJlZSkuc2V0UGFyZW50KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kY2hhbmdlcy5yb290LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmluaXRpb24uaW5kZXhlc1tmaWVsZF0sXG4gICAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICAvLyBTZXR0aW5nIGEgZmllbGQgdG8gYG51bGxgIG9yIGB1bmRlZmluZWRgIHdpbGwgZGVsZXRlIGl0LlxuICAgICAgICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLiRjaGFuZ2VzLmRlbGV0ZShmaWVsZCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpc1tmaWVsZENhY2hlZF0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG5cbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogYEBmaWx0ZXIoKWAgZGVjb3JhdG9yIGZvciBkZWZpbmluZyBkYXRhIGZpbHRlcnMgcGVyIGNsaWVudFxuICovXG5cbmV4cG9ydCBmdW5jdGlvbiBmaWx0ZXI8VCBleHRlbmRzIFNjaGVtYSwgViwgUiBleHRlbmRzIFNjaGVtYT4oY2I6IEZpbHRlckNhbGxiYWNrPFQsIFYsIFI+KTogUHJvcGVydHlEZWNvcmF0b3Ige1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIGZpZWxkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgdHlwZW9mIFNjaGVtYTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuXG4gICAgICAgIGlmIChkZWZpbml0aW9uLmFkZEZpbHRlcihmaWVsZCwgY2IpKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5fY29udGV4dC51c2VGaWx0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGZpbHRlckNoaWxkcmVuPFQgZXh0ZW5kcyBTY2hlbWEsIEssIFYsIFIgZXh0ZW5kcyBTY2hlbWE+KGNiOiBGaWx0ZXJDaGlsZHJlbkNhbGxiYWNrPFQsIEssIFYsIFI+KTogUHJvcGVydHlEZWNvcmF0b3Ige1xuICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0OiBhbnksIGZpZWxkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgdHlwZW9mIFNjaGVtYTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuICAgICAgICBpZiAoZGVmaW5pdGlvbi5hZGRDaGlsZHJlbkZpbHRlcihmaWVsZCwgY2IpKSB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvci5fY29udGV4dC51c2VGaWx0ZXJzID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuXG4vKipcbiAqIGBAZGVwcmVjYXRlZCgpYCBmbGFnIGEgZmllbGQgYXMgZGVwcmVjYXRlZC5cbiAqIFRoZSBwcmV2aW91cyBgQHR5cGUoKWAgYW5ub3RhdGlvbiBzaG91bGQgcmVtYWluIGFsb25nIHdpdGggdGhpcyBvbmUuXG4gKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGRlcHJlY2F0ZWQodGhyb3dzOiBib29sZWFuID0gdHJ1ZSwgY29udGV4dDogQ29udGV4dCA9IGdsb2JhbENvbnRleHQpOiBQcm9wZXJ0eURlY29yYXRvciB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh0YXJnZXQ6IHR5cGVvZiBTY2hlbWEsIGZpZWxkOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3QgY29uc3RydWN0b3IgPSB0YXJnZXQuY29uc3RydWN0b3IgYXMgdHlwZW9mIFNjaGVtYTtcbiAgICAgICAgY29uc3QgZGVmaW5pdGlvbiA9IGNvbnN0cnVjdG9yLl9kZWZpbml0aW9uO1xuXG4gICAgICAgIGRlZmluaXRpb24uZGVwcmVjYXRlZFtmaWVsZF0gPSB0cnVlO1xuXG4gICAgICAgIGlmICh0aHJvd3MpIHtcbiAgICAgICAgICAgIGRlZmluaXRpb24uZGVzY3JpcHRvcnNbZmllbGRdID0ge1xuICAgICAgICAgICAgICAgIGdldDogZnVuY3Rpb24gKCkgeyB0aHJvdyBuZXcgRXJyb3IoYCR7ZmllbGR9IGlzIGRlcHJlY2F0ZWQuYCk7IH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodGhpczogU2NoZW1hLCB2YWx1ZTogYW55KSB7IC8qIHRocm93IG5ldyBFcnJvcihgJHtmaWVsZH0gaXMgZGVwcmVjYXRlZC5gKTsgKi8gfSxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZpbmVUeXBlcyhcbiAgICB0YXJnZXQ6IHR5cGVvZiBTY2hlbWEsXG4gICAgZmllbGRzOiB7IFtwcm9wZXJ0eTogc3RyaW5nXTogRGVmaW5pdGlvblR5cGUgfSxcbiAgICBjb250ZXh0OiBDb250ZXh0ID0gdGFyZ2V0Ll9jb250ZXh0IHx8IGdsb2JhbENvbnRleHRcbikge1xuICAgIGZvciAobGV0IGZpZWxkIGluIGZpZWxkcykge1xuICAgICAgICB0eXBlKGZpZWxkc1tmaWVsZF0sIGNvbnRleHQpKHRhcmdldC5wcm90b3R5cGUsIGZpZWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbiJdfQ==