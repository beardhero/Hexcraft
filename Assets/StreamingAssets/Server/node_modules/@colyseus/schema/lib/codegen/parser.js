"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseFiles = void 0;
var ts = require("typescript");
var path = require("path");
var fs_1 = require("fs");
var types_1 = require("./types");
var currentStructure;
var currentProperty;
var globalContext;
function defineProperty(property, initializer) {
    if (ts.isIdentifier(initializer)) {
        property.type = "ref";
        property.childType = initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ObjectLiteralExpression) {
        property.type = "map";
        property.childType = initializer.properties[0].initializer.text;
    }
    else if (initializer.kind == ts.SyntaxKind.ArrayLiteralExpression) {
        property.type = "array";
        property.childType = initializer.elements[0].text;
    }
    else {
        property.type = initializer.text;
    }
}
function inspectNode(node, context, decoratorName) {
    var _a, _b, _c, _d, _e;
    switch (node.kind) {
        case ts.SyntaxKind.ImportClause:
            var specifier = node.parent.moduleSpecifier;
            if (specifier && specifier.text.startsWith('.')) {
                var currentDir = path.dirname(node.getSourceFile().fileName);
                var pathToImport = path.resolve(currentDir, specifier.text);
                parseFiles([pathToImport], decoratorName, globalContext);
            }
            break;
        case ts.SyntaxKind.ClassDeclaration:
            currentStructure = new types_1.Class();
            var heritageClauses = node.heritageClauses;
            if (heritageClauses && heritageClauses.length > 0) {
                currentStructure.extends = heritageClauses[0].types[0].expression.getText();
            }
            context.addStructure(currentStructure);
            break;
        case ts.SyntaxKind.InterfaceDeclaration:
            //
            // Only generate Interfaces if it has "Message" on its name.
            // Example: MyMessage
            //
            var interfaceName = node.name.escapedText.toString();
            if (interfaceName.indexOf("Message") !== -1) {
                currentStructure = new types_1.Interface();
                currentStructure.name = interfaceName;
                context.addStructure(currentStructure);
            }
            break;
        case ts.SyntaxKind.ExtendsKeyword:
            // console.log(node.getText());
            break;
        case ts.SyntaxKind.PropertySignature:
            if (currentStructure instanceof types_1.Interface) {
                var interfaceDeclaration = node.parent;
                if (currentStructure.name !== interfaceDeclaration.name.escapedText.toString()) {
                    // skip if property if for a another interface than the one we're interested in.
                    break;
                }
                // define a property of an interface
                var property = new types_1.Property();
                property.name = node.name.escapedText.toString();
                property.type = node.type.getText();
                currentStructure.addProperty(property);
            }
            break;
        case ts.SyntaxKind.Identifier:
            if (node.getText() === "deprecated" &&
                node.parent.kind !== ts.SyntaxKind.ImportSpecifier) {
                currentProperty = new types_1.Property();
                currentProperty.deprecated = true;
                break;
            }
            if (node.getText() === decoratorName) {
                var prop = (_b = (_a = node.parent) === null || _a === void 0 ? void 0 : _a.parent) === null || _b === void 0 ? void 0 : _b.parent;
                var propDecorator = prop === null || prop === void 0 ? void 0 : prop.decorators;
                var hasExpression = (_c = prop === null || prop === void 0 ? void 0 : prop.expression) === null || _c === void 0 ? void 0 : _c.arguments;
                /**
                 * neither a `@type()` decorator or `type()` call. skip.
                 */
                if (!propDecorator && !hasExpression) {
                    break;
                }
                // using as decorator
                if (propDecorator) {
                    /**
                     * Calling `@type()` as decorator
                     */
                    var typeDecorator = propDecorator.find((function (decorator) {
                        return decorator.expression.expression.escapedText === decoratorName;
                    })).expression;
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    var typeArgument = typeDecorator.arguments[0];
                    defineProperty(property, typeArgument);
                }
                else if (((_d = prop.expression.arguments) === null || _d === void 0 ? void 0 : _d[1]) && ((_e = prop.expression.expression.arguments) === null || _e === void 0 ? void 0 : _e[0])) {
                    /**
                     * Calling `type()` as a regular method
                     */
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.expression.arguments[1].text;
                    currentStructure.addProperty(property);
                    var typeArgument = prop.expression.expression.arguments[0];
                    defineProperty(property, typeArgument);
                }
            }
            else if (node.getText() === "defineTypes" &&
                (node.parent.kind === ts.SyntaxKind.CallExpression ||
                    node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)) {
                /**
                 * JavaScript source file (`.js`)
                 * Using `defineTypes()`
                 */
                var callExpression = (node.parent.kind === ts.SyntaxKind.PropertyAccessExpression)
                    ? node.parent.parent
                    : node.parent;
                if (callExpression.kind !== ts.SyntaxKind.CallExpression) {
                    break;
                }
                var className = callExpression.arguments[0].getText();
                currentStructure.name = className;
                var types = callExpression.arguments[1];
                for (var i = 0; i < types.properties.length; i++) {
                    var prop = types.properties[i];
                    var property = currentProperty || new types_1.Property();
                    property.name = prop.name.escapedText;
                    currentStructure.addProperty(property);
                    defineProperty(property, prop.initializer);
                }
            }
            if (node.parent.kind === ts.SyntaxKind.ClassDeclaration) {
                currentStructure.name = node.getText();
            }
            currentProperty = undefined;
            break;
    }
    ts.forEachChild(node, function (n) { return inspectNode(n, context, decoratorName); });
}
var parsedFiles;
function parseFiles(fileNames, decoratorName, context) {
    if (decoratorName === void 0) { decoratorName = "type"; }
    if (context === void 0) { context = new types_1.Context(); }
    /**
     * Re-set globalContext for each test case
     */
    if (globalContext !== context) {
        parsedFiles = {};
        globalContext = context;
    }
    fileNames.forEach(function (fileName) {
        var sourceFile;
        var sourceFileName;
        var fileNameAlternatives = [];
        if (!fileName.endsWith(".ts") && !fileName.endsWith(".js")) {
            fileNameAlternatives.push(fileName + ".ts");
            fileNameAlternatives.push(fileName + "/index.ts");
        }
        else {
            fileNameAlternatives.push(fileName);
        }
        for (var i = 0; i < fileNameAlternatives.length; i++) {
            try {
                sourceFileName = path.resolve(fileNameAlternatives[i]);
                if (parsedFiles[sourceFileName]) {
                    break;
                }
                sourceFile = ts.createSourceFile(sourceFileName, fs_1.readFileSync(sourceFileName).toString(), ts.ScriptTarget.Latest, true);
                parsedFiles[sourceFileName] = true;
                break;
            }
            catch (e) {
                // console.log(`${fileNameAlternatives[i]} => ${e.message}`);
            }
        }
        if (sourceFile) {
            inspectNode(sourceFile, context, decoratorName);
        }
    });
    return context.getStructures();
}
exports.parseFiles = parseFiles;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2NvZGVnZW4vcGFyc2VyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUFBLCtCQUFpQztBQUNqQywyQkFBNkI7QUFDN0IseUJBQWtDO0FBQ2xDLGlDQUEwRTtBQUUxRSxJQUFJLGdCQUE0QixDQUFDO0FBQ2pDLElBQUksZUFBeUIsQ0FBQztBQUU5QixJQUFJLGFBQXNCLENBQUM7QUFFM0IsU0FBUyxjQUFjLENBQUMsUUFBa0IsRUFBRSxXQUFnQjtJQUN4RCxJQUFJLEVBQUUsQ0FBQyxZQUFZLENBQUMsV0FBVyxDQUFDLEVBQUU7UUFDOUIsUUFBUSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDdEIsUUFBUSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsSUFBSSxDQUFDO0tBRXpDO1NBQU0sSUFBSSxXQUFXLENBQUMsSUFBSSxJQUFJLEVBQUUsQ0FBQyxVQUFVLENBQUMsdUJBQXVCLEVBQUU7UUFDbEUsUUFBUSxDQUFDLElBQUksR0FBRyxLQUFLLENBQUM7UUFDdEIsUUFBUSxDQUFDLFNBQVMsR0FBRyxXQUFXLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7S0FFbkU7U0FBTSxJQUFJLFdBQVcsQ0FBQyxJQUFJLElBQUksRUFBRSxDQUFDLFVBQVUsQ0FBQyxzQkFBc0IsRUFBRTtRQUNqRSxRQUFRLENBQUMsSUFBSSxHQUFHLE9BQU8sQ0FBQztRQUN4QixRQUFRLENBQUMsU0FBUyxHQUFHLFdBQVcsQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO0tBRXJEO1NBQU07UUFDSCxRQUFRLENBQUMsSUFBSSxHQUFHLFdBQVcsQ0FBQyxJQUFJLENBQUM7S0FDcEM7QUFDTCxDQUFDO0FBRUQsU0FBUyxXQUFXLENBQUMsSUFBYSxFQUFFLE9BQWdCLEVBQUUsYUFBcUI7O0lBQ3ZFLFFBQVEsSUFBSSxDQUFDLElBQUksRUFBRTtRQUNmLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxZQUFZO1lBQzNCLElBQU0sU0FBUyxHQUFJLElBQUksQ0FBQyxNQUFjLENBQUMsZUFBZSxDQUFDO1lBQ3ZELElBQUksU0FBUyxJQUFLLFNBQVMsQ0FBQyxJQUFlLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxFQUFHO2dCQUMxRCxJQUFNLFVBQVUsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxhQUFhLEVBQUUsQ0FBQyxRQUFRLENBQUMsQ0FBQztnQkFDL0QsSUFBTSxZQUFZLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQyxVQUFVLEVBQUUsU0FBUyxDQUFDLElBQUksQ0FBQyxDQUFDO2dCQUM5RCxVQUFVLENBQUMsQ0FBQyxZQUFZLENBQUMsRUFBRSxhQUFhLEVBQUUsYUFBYSxDQUFDLENBQUM7YUFDNUQ7WUFDRCxNQUFNO1FBRVYsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGdCQUFnQjtZQUMvQixnQkFBZ0IsR0FBRyxJQUFJLGFBQUssRUFBRSxDQUFDO1lBRS9CLElBQU0sZUFBZSxHQUFJLElBQW9DLENBQUMsZUFBZSxDQUFDO1lBQzlFLElBQUksZUFBZSxJQUFJLGVBQWUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO2dCQUM5QyxnQkFBMEIsQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUMsT0FBTyxFQUFFLENBQUM7YUFDMUY7WUFFRCxPQUFPLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7WUFDdkMsTUFBTTtRQUVWLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxvQkFBb0I7WUFDbkMsRUFBRTtZQUNGLDREQUE0RDtZQUM1RCxxQkFBcUI7WUFDckIsRUFBRTtZQUNGLElBQU0sYUFBYSxHQUFJLElBQW9DLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztZQUN4RixJQUFJLGFBQWEsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUU7Z0JBQ3pDLGdCQUFnQixHQUFHLElBQUksaUJBQVMsRUFBRSxDQUFDO2dCQUNuQyxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsYUFBYSxDQUFDO2dCQUV0QyxPQUFPLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDLENBQUM7YUFDMUM7WUFDRCxNQUFNO1FBRVYsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWM7WUFDN0IsK0JBQStCO1lBQy9CLE1BQU07UUFFVixLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsaUJBQWlCO1lBQ2hDLElBQUksZ0JBQWdCLFlBQVksaUJBQVMsRUFBRTtnQkFDdkMsSUFBTSxvQkFBb0IsR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO2dCQUV6QyxJQUNJLGdCQUFnQixDQUFDLElBQUksS0FBTSxvQkFBb0QsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLFFBQVEsRUFBRSxFQUM3RztvQkFDRSxnRkFBZ0Y7b0JBQ2hGLE1BQU07aUJBQ1Q7Z0JBRUQsb0NBQW9DO2dCQUNwQyxJQUFNLFFBQVEsR0FBRyxJQUFJLGdCQUFRLEVBQUUsQ0FBQztnQkFDaEMsUUFBUSxDQUFDLElBQUksR0FBSSxJQUFZLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxRQUFRLEVBQUUsQ0FBQztnQkFDMUQsUUFBUSxDQUFDLElBQUksR0FBSSxJQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxDQUFDO2dCQUM3QyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7YUFDMUM7WUFDRCxNQUFNO1FBRVYsS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLFVBQVU7WUFDekIsSUFDSSxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssWUFBWTtnQkFDL0IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxlQUFlLEVBQ3BEO2dCQUNFLGVBQWUsR0FBRyxJQUFJLGdCQUFRLEVBQUUsQ0FBQztnQkFDakMsZUFBZSxDQUFDLFVBQVUsR0FBRyxJQUFJLENBQUM7Z0JBQ2xDLE1BQU07YUFDVDtZQUVELElBQUksSUFBSSxDQUFDLE9BQU8sRUFBRSxLQUFLLGFBQWEsRUFBRTtnQkFDbEMsSUFBTSxJQUFJLGVBQVEsSUFBSSxDQUFDLE1BQU0sMENBQUUsTUFBTSwwQ0FBRSxNQUFNLENBQUM7Z0JBQzlDLElBQU0sYUFBYSxHQUFHLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxVQUFVLENBQUM7Z0JBQ3ZDLElBQU0sYUFBYSxTQUFHLElBQUksYUFBSixJQUFJLHVCQUFKLElBQUksQ0FBRSxVQUFVLDBDQUFFLFNBQVMsQ0FBQztnQkFFbEQ7O21CQUVHO2dCQUNILElBQUksQ0FBQyxhQUFhLElBQUksQ0FBQyxhQUFhLEVBQUU7b0JBQ2xDLE1BQU07aUJBQ1Q7Z0JBRUQscUJBQXFCO2dCQUNyQixJQUFJLGFBQWEsRUFBRTtvQkFDZjs7dUJBRUc7b0JBQ0gsSUFBTSxhQUFhLEdBQVEsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLFVBQUEsU0FBUzt3QkFDcEQsT0FBUSxTQUFTLENBQUMsVUFBa0IsQ0FBQyxVQUFVLENBQUMsV0FBVyxLQUFLLGFBQWEsQ0FBQztvQkFDbEYsQ0FBQyxDQUFDLENBQUMsQ0FBQyxVQUFVLENBQUM7b0JBRWYsSUFBTSxRQUFRLEdBQUcsZUFBZSxJQUFJLElBQUksZ0JBQVEsRUFBRSxDQUFDO29CQUNuRCxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDO29CQUN0QyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsUUFBUSxDQUFDLENBQUM7b0JBRXZDLElBQU0sWUFBWSxHQUFHLGFBQWEsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQ2hELGNBQWMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7aUJBRTFDO3FCQUFNLElBQ0gsT0FBQSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsMENBQUcsQ0FBQyxhQUM3QixJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLDBDQUFHLENBQUMsRUFBQyxFQUMzQztvQkFDRTs7dUJBRUc7b0JBQ0gsSUFBTSxRQUFRLEdBQUcsZUFBZSxJQUFJLElBQUksZ0JBQVEsRUFBRSxDQUFDO29CQUNuRCxRQUFRLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQztvQkFDbEQsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUV2QyxJQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBQzdELGNBQWMsQ0FBQyxRQUFRLEVBQUUsWUFBWSxDQUFDLENBQUM7aUJBQzFDO2FBR0o7aUJBQU0sSUFDSCxJQUFJLENBQUMsT0FBTyxFQUFFLEtBQUssYUFBYTtnQkFDaEMsQ0FDSSxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWM7b0JBQ2pELElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQzlELEVBQ0g7Z0JBQ0U7OzttQkFHRztnQkFDSCxJQUFNLGNBQWMsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxLQUFLLEVBQUUsQ0FBQyxVQUFVLENBQUMsd0JBQXdCLENBQUM7b0JBQ2hGLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLE1BQTJCO29CQUN6QyxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQTJCLENBQUM7Z0JBRXZDLElBQUksY0FBYyxDQUFDLElBQUksS0FBSyxFQUFFLENBQUMsVUFBVSxDQUFDLGNBQWMsRUFBRTtvQkFDdEQsTUFBTTtpQkFDVDtnQkFFRCxJQUFNLFNBQVMsR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBQyxDQUFDLE9BQU8sRUFBRSxDQUFBO2dCQUN2RCxnQkFBZ0IsQ0FBQyxJQUFJLEdBQUcsU0FBUyxDQUFDO2dCQUVsQyxJQUFNLEtBQUssR0FBRyxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUMsQ0FBUSxDQUFDO2dCQUNqRCxLQUFLLElBQUksQ0FBQyxHQUFDLENBQUMsRUFBRSxDQUFDLEdBQUMsS0FBSyxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxFQUFFLEVBQUU7b0JBQzFDLElBQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLENBQUM7b0JBRWpDLElBQU0sUUFBUSxHQUFHLGVBQWUsSUFBSSxJQUFJLGdCQUFRLEVBQUUsQ0FBQztvQkFDbkQsUUFBUSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQztvQkFDdEMsZ0JBQWdCLENBQUMsV0FBVyxDQUFDLFFBQVEsQ0FBQyxDQUFDO29CQUV2QyxjQUFjLENBQUMsUUFBUSxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztpQkFDOUM7YUFFSjtZQUVELElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssRUFBRSxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsRUFBRTtnQkFDckQsZ0JBQWdCLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxPQUFPLEVBQUUsQ0FBQzthQUMxQztZQUVELGVBQWUsR0FBRyxTQUFTLENBQUM7WUFFNUIsTUFBTTtLQUNiO0lBRUQsRUFBRSxDQUFDLFlBQVksQ0FBQyxJQUFJLEVBQUUsVUFBQyxDQUFDLElBQUssT0FBQSxXQUFXLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxhQUFhLENBQUMsRUFBdEMsQ0FBc0MsQ0FBQyxDQUFDO0FBQ3pFLENBQUM7QUFFRCxJQUFJLFdBQTRDLENBQUM7QUFFakQsU0FBZ0IsVUFBVSxDQUN0QixTQUFtQixFQUNuQixhQUE4QixFQUM5QixPQUFnQztJQURoQyw4QkFBQSxFQUFBLHNCQUE4QjtJQUM5Qix3QkFBQSxFQUFBLGNBQXVCLGVBQU8sRUFBRTtJQUVoQzs7T0FFRztJQUNILElBQUksYUFBYSxLQUFLLE9BQU8sRUFBRTtRQUMzQixXQUFXLEdBQUcsRUFBRSxDQUFDO1FBQ2pCLGFBQWEsR0FBRyxPQUFPLENBQUM7S0FDM0I7SUFFRCxTQUFTLENBQUMsT0FBTyxDQUFDLFVBQUMsUUFBUTtRQUN2QixJQUFJLFVBQW1CLENBQUM7UUFDeEIsSUFBSSxjQUFzQixDQUFDO1FBRTNCLElBQU0sb0JBQW9CLEdBQUcsRUFBRSxDQUFDO1FBRWhDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUN4RCxvQkFBb0IsQ0FBQyxJQUFJLENBQUksUUFBUSxRQUFLLENBQUMsQ0FBQztZQUM1QyxvQkFBb0IsQ0FBQyxJQUFJLENBQUksUUFBUSxjQUFXLENBQUMsQ0FBQztTQUVyRDthQUFNO1lBQ0gsb0JBQW9CLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1NBQ3ZDO1FBRUQsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtZQUNsRCxJQUFJO2dCQUNBLGNBQWMsR0FBRyxJQUFJLENBQUMsT0FBTyxDQUFDLG9CQUFvQixDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7Z0JBRXZELElBQUksV0FBVyxDQUFDLGNBQWMsQ0FBQyxFQUFFO29CQUM3QixNQUFNO2lCQUNUO2dCQUVELFVBQVUsR0FBRyxFQUFFLENBQUMsZ0JBQWdCLENBQzVCLGNBQWMsRUFDZCxpQkFBWSxDQUFDLGNBQWMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUN2QyxFQUFFLENBQUMsWUFBWSxDQUFDLE1BQU0sRUFDdEIsSUFBSSxDQUNQLENBQUM7Z0JBRUYsV0FBVyxDQUFDLGNBQWMsQ0FBQyxHQUFHLElBQUksQ0FBQztnQkFFbkMsTUFBTTthQUNUO1lBQUMsT0FBTyxDQUFDLEVBQUU7Z0JBQ1IsNkRBQTZEO2FBQ2hFO1NBQ0o7UUFFRCxJQUFJLFVBQVUsRUFBRTtZQUNaLFdBQVcsQ0FBQyxVQUFVLEVBQUUsT0FBTyxFQUFFLGFBQWEsQ0FBQyxDQUFDO1NBQ25EO0lBQ0wsQ0FBQyxDQUFDLENBQUM7SUFFSCxPQUFPLE9BQU8sQ0FBQyxhQUFhLEVBQUUsQ0FBQztBQUNuQyxDQUFDO0FBeERELGdDQXdEQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIHRzIGZyb20gXCJ0eXBlc2NyaXB0XCI7XG5pbXBvcnQgKiBhcyBwYXRoIGZyb20gXCJwYXRoXCI7XG5pbXBvcnQgeyByZWFkRmlsZVN5bmMgfSBmcm9tIFwiZnNcIjtcbmltcG9ydCB7IElTdHJ1Y3R1cmUsIENsYXNzLCBJbnRlcmZhY2UsIFByb3BlcnR5LCBDb250ZXh0IH0gZnJvbSBcIi4vdHlwZXNcIjtcblxubGV0IGN1cnJlbnRTdHJ1Y3R1cmU6IElTdHJ1Y3R1cmU7XG5sZXQgY3VycmVudFByb3BlcnR5OiBQcm9wZXJ0eTtcblxubGV0IGdsb2JhbENvbnRleHQ6IENvbnRleHQ7XG5cbmZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KHByb3BlcnR5OiBQcm9wZXJ0eSwgaW5pdGlhbGl6ZXI6IGFueSkge1xuICAgIGlmICh0cy5pc0lkZW50aWZpZXIoaW5pdGlhbGl6ZXIpKSB7XG4gICAgICAgIHByb3BlcnR5LnR5cGUgPSBcInJlZlwiO1xuICAgICAgICBwcm9wZXJ0eS5jaGlsZFR5cGUgPSBpbml0aWFsaXplci50ZXh0O1xuXG4gICAgfSBlbHNlIGlmIChpbml0aWFsaXplci5raW5kID09IHRzLlN5bnRheEtpbmQuT2JqZWN0TGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAgICAgcHJvcGVydHkudHlwZSA9IFwibWFwXCI7XG4gICAgICAgIHByb3BlcnR5LmNoaWxkVHlwZSA9IGluaXRpYWxpemVyLnByb3BlcnRpZXNbMF0uaW5pdGlhbGl6ZXIudGV4dDtcblxuICAgIH0gZWxzZSBpZiAoaW5pdGlhbGl6ZXIua2luZCA9PSB0cy5TeW50YXhLaW5kLkFycmF5TGl0ZXJhbEV4cHJlc3Npb24pIHtcbiAgICAgICAgcHJvcGVydHkudHlwZSA9IFwiYXJyYXlcIjtcbiAgICAgICAgcHJvcGVydHkuY2hpbGRUeXBlID0gaW5pdGlhbGl6ZXIuZWxlbWVudHNbMF0udGV4dDtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIHByb3BlcnR5LnR5cGUgPSBpbml0aWFsaXplci50ZXh0O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gaW5zcGVjdE5vZGUobm9kZTogdHMuTm9kZSwgY29udGV4dDogQ29udGV4dCwgZGVjb3JhdG9yTmFtZTogc3RyaW5nKSB7XG4gICAgc3dpdGNoIChub2RlLmtpbmQpIHtcbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkltcG9ydENsYXVzZTpcbiAgICAgICAgICAgIGNvbnN0IHNwZWNpZmllciA9IChub2RlLnBhcmVudCBhcyBhbnkpLm1vZHVsZVNwZWNpZmllcjtcbiAgICAgICAgICAgIGlmIChzcGVjaWZpZXIgJiYgKHNwZWNpZmllci50ZXh0IGFzIHN0cmluZykuc3RhcnRzV2l0aCgnLicpKSAge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREaXIgPSBwYXRoLmRpcm5hbWUobm9kZS5nZXRTb3VyY2VGaWxlKCkuZmlsZU5hbWUpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhdGhUb0ltcG9ydCA9IHBhdGgucmVzb2x2ZShjdXJyZW50RGlyLCBzcGVjaWZpZXIudGV4dCk7XG4gICAgICAgICAgICAgICAgcGFyc2VGaWxlcyhbcGF0aFRvSW1wb3J0XSwgZGVjb3JhdG9yTmFtZSwgZ2xvYmFsQ29udGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbjpcbiAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUgPSBuZXcgQ2xhc3MoKTtcblxuICAgICAgICAgICAgY29uc3QgaGVyaXRhZ2VDbGF1c2VzID0gKG5vZGUgYXMgdHMuQ2xhc3NMaWtlRGVjbGFyYXRpb25CYXNlKS5oZXJpdGFnZUNsYXVzZXM7XG4gICAgICAgICAgICBpZiAoaGVyaXRhZ2VDbGF1c2VzICYmIGhlcml0YWdlQ2xhdXNlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgKGN1cnJlbnRTdHJ1Y3R1cmUgYXMgQ2xhc3MpLmV4dGVuZHMgPSBoZXJpdGFnZUNsYXVzZXNbMF0udHlwZXNbMF0uZXhwcmVzc2lvbi5nZXRUZXh0KCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnRleHQuYWRkU3RydWN0dXJlKGN1cnJlbnRTdHJ1Y3R1cmUpO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgY2FzZSB0cy5TeW50YXhLaW5kLkludGVyZmFjZURlY2xhcmF0aW9uOlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC8vIE9ubHkgZ2VuZXJhdGUgSW50ZXJmYWNlcyBpZiBpdCBoYXMgXCJNZXNzYWdlXCIgb24gaXRzIG5hbWUuXG4gICAgICAgICAgICAvLyBFeGFtcGxlOiBNeU1lc3NhZ2VcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICBjb25zdCBpbnRlcmZhY2VOYW1lID0gKG5vZGUgYXMgdHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKS5uYW1lLmVzY2FwZWRUZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBpZiAoaW50ZXJmYWNlTmFtZS5pbmRleE9mKFwiTWVzc2FnZVwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlID0gbmV3IEludGVyZmFjZSgpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUubmFtZSA9IGludGVyZmFjZU5hbWU7XG5cbiAgICAgICAgICAgICAgICBjb250ZXh0LmFkZFN0cnVjdHVyZShjdXJyZW50U3RydWN0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5FeHRlbmRzS2V5d29yZDpcbiAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKG5vZGUuZ2V0VGV4dCgpKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGNhc2UgdHMuU3ludGF4S2luZC5Qcm9wZXJ0eVNpZ25hdHVyZTpcbiAgICAgICAgICAgIGlmIChjdXJyZW50U3RydWN0dXJlIGluc3RhbmNlb2YgSW50ZXJmYWNlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW50ZXJmYWNlRGVjbGFyYXRpb24gPSBub2RlLnBhcmVudDtcblxuICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5uYW1lICE9PSAoaW50ZXJmYWNlRGVjbGFyYXRpb24gYXMgdHMuVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uKS5uYW1lLmVzY2FwZWRUZXh0LnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc2tpcCBpZiBwcm9wZXJ0eSBpZiBmb3IgYSBhbm90aGVyIGludGVyZmFjZSB0aGFuIHRoZSBvbmUgd2UncmUgaW50ZXJlc3RlZCBpbi5cbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgLy8gZGVmaW5lIGEgcHJvcGVydHkgb2YgYW4gaW50ZXJmYWNlXG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBuZXcgUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICBwcm9wZXJ0eS5uYW1lID0gKG5vZGUgYXMgYW55KS5uYW1lLmVzY2FwZWRUZXh0LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgcHJvcGVydHkudHlwZSA9IChub2RlIGFzIGFueSkudHlwZS5nZXRUZXh0KCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5hZGRQcm9wZXJ0eShwcm9wZXJ0eSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIHRzLlN5bnRheEtpbmQuSWRlbnRpZmllcjpcbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICBub2RlLmdldFRleHQoKSA9PT0gXCJkZXByZWNhdGVkXCIgJiZcbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudC5raW5kICE9PSB0cy5TeW50YXhLaW5kLkltcG9ydFNwZWNpZmllclxuICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5ID0gbmV3IFByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3BlcnR5LmRlcHJlY2F0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAobm9kZS5nZXRUZXh0KCkgPT09IGRlY29yYXRvck5hbWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwcm9wOiBhbnkgPSBub2RlLnBhcmVudD8ucGFyZW50Py5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvcERlY29yYXRvciA9IHByb3A/LmRlY29yYXRvcnM7XG4gICAgICAgICAgICAgICAgY29uc3QgaGFzRXhwcmVzc2lvbiA9IHByb3A/LmV4cHJlc3Npb24/LmFyZ3VtZW50cztcblxuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIG5laXRoZXIgYSBgQHR5cGUoKWAgZGVjb3JhdG9yIG9yIGB0eXBlKClgIGNhbGwuIHNraXAuXG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgaWYgKCFwcm9wRGVjb3JhdG9yICYmICFoYXNFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIHVzaW5nIGFzIGRlY29yYXRvclxuICAgICAgICAgICAgICAgIGlmIChwcm9wRGVjb3JhdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxsaW5nIGBAdHlwZSgpYCBhcyBkZWNvcmF0b3JcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHR5cGVEZWNvcmF0b3I6IGFueSA9IHByb3BEZWNvcmF0b3IuZmluZCgoZGVjb3JhdG9yID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAoZGVjb3JhdG9yLmV4cHJlc3Npb24gYXMgYW55KS5leHByZXNzaW9uLmVzY2FwZWRUZXh0ID09PSBkZWNvcmF0b3JOYW1lO1xuICAgICAgICAgICAgICAgICAgICB9KSkuZXhwcmVzc2lvbjtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGN1cnJlbnRQcm9wZXJ0eSB8fCBuZXcgUHJvcGVydHkoKTtcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydHkubmFtZSA9IHByb3AubmFtZS5lc2NhcGVkVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudFN0cnVjdHVyZS5hZGRQcm9wZXJ0eShwcm9wZXJ0eSk7XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdHlwZUFyZ3VtZW50ID0gdHlwZURlY29yYXRvci5hcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3BlcnR5LCB0eXBlQXJndW1lbnQpO1xuXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgICAgcHJvcC5leHByZXNzaW9uLmFyZ3VtZW50cz8uWzFdICYmXG4gICAgICAgICAgICAgICAgICAgIHByb3AuZXhwcmVzc2lvbi5leHByZXNzaW9uLmFyZ3VtZW50cz8uWzBdXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxsaW5nIGB0eXBlKClgIGFzIGEgcmVndWxhciBtZXRob2RcbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByb3BlcnR5ID0gY3VycmVudFByb3BlcnR5IHx8IG5ldyBQcm9wZXJ0eSgpO1xuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0eS5uYW1lID0gcHJvcC5leHByZXNzaW9uLmFyZ3VtZW50c1sxXS50ZXh0O1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLmFkZFByb3BlcnR5KHByb3BlcnR5KTtcblxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eXBlQXJndW1lbnQgPSBwcm9wLmV4cHJlc3Npb24uZXhwcmVzc2lvbi5hcmd1bWVudHNbMF07XG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3BlcnR5LCB0eXBlQXJndW1lbnQpO1xuICAgICAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgICAgIG5vZGUuZ2V0VGV4dCgpID09PSBcImRlZmluZVR5cGVzXCIgJiZcbiAgICAgICAgICAgICAgICAoXG4gICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2FsbEV4cHJlc3Npb24gfHxcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQua2luZCA9PT0gdHMuU3ludGF4S2luZC5Qcm9wZXJ0eUFjY2Vzc0V4cHJlc3Npb25cbiAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiBKYXZhU2NyaXB0IHNvdXJjZSBmaWxlIChgLmpzYClcbiAgICAgICAgICAgICAgICAgKiBVc2luZyBgZGVmaW5lVHlwZXMoKWBcbiAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICBjb25zdCBjYWxsRXhwcmVzc2lvbiA9IChub2RlLnBhcmVudC5raW5kID09PSB0cy5TeW50YXhLaW5kLlByb3BlcnR5QWNjZXNzRXhwcmVzc2lvbilcbiAgICAgICAgICAgICAgICAgICAgPyBub2RlLnBhcmVudC5wYXJlbnQgYXMgdHMuQ2FsbEV4cHJlc3Npb25cbiAgICAgICAgICAgICAgICAgICAgOiBub2RlLnBhcmVudCBhcyB0cy5DYWxsRXhwcmVzc2lvbjtcblxuICAgICAgICAgICAgICAgIGlmIChjYWxsRXhwcmVzc2lvbi5raW5kICE9PSB0cy5TeW50YXhLaW5kLkNhbGxFeHByZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGNvbnN0IGNsYXNzTmFtZSA9IGNhbGxFeHByZXNzaW9uLmFyZ3VtZW50c1swXS5nZXRUZXh0KClcbiAgICAgICAgICAgICAgICBjdXJyZW50U3RydWN0dXJlLm5hbWUgPSBjbGFzc05hbWU7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlcyA9IGNhbGxFeHByZXNzaW9uLmFyZ3VtZW50c1sxXSBhcyBhbnk7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaT0wOyBpPHR5cGVzLnByb3BlcnRpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcCA9IHR5cGVzLnByb3BlcnRpZXNbaV07XG5cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvcGVydHkgPSBjdXJyZW50UHJvcGVydHkgfHwgbmV3IFByb3BlcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHByb3BlcnR5Lm5hbWUgPSBwcm9wLm5hbWUuZXNjYXBlZFRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUuYWRkUHJvcGVydHkocHJvcGVydHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGRlZmluZVByb3BlcnR5KHByb3BlcnR5LCBwcm9wLmluaXRpYWxpemVyKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUucGFyZW50LmtpbmQgPT09IHRzLlN5bnRheEtpbmQuQ2xhc3NEZWNsYXJhdGlvbikge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRTdHJ1Y3R1cmUubmFtZSA9IG5vZGUuZ2V0VGV4dCgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjdXJyZW50UHJvcGVydHkgPSB1bmRlZmluZWQ7XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRzLmZvckVhY2hDaGlsZChub2RlLCAobikgPT4gaW5zcGVjdE5vZGUobiwgY29udGV4dCwgZGVjb3JhdG9yTmFtZSkpO1xufVxuXG5sZXQgcGFyc2VkRmlsZXM6IHsgW2ZpbGVuYW1lOiBzdHJpbmddOiBib29sZWFuIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUZpbGVzKFxuICAgIGZpbGVOYW1lczogc3RyaW5nW10sXG4gICAgZGVjb3JhdG9yTmFtZTogc3RyaW5nID0gXCJ0eXBlXCIsXG4gICAgY29udGV4dDogQ29udGV4dCA9IG5ldyBDb250ZXh0KClcbikge1xuICAgIC8qKlxuICAgICAqIFJlLXNldCBnbG9iYWxDb250ZXh0IGZvciBlYWNoIHRlc3QgY2FzZVxuICAgICAqL1xuICAgIGlmIChnbG9iYWxDb250ZXh0ICE9PSBjb250ZXh0KSB7XG4gICAgICAgIHBhcnNlZEZpbGVzID0ge307XG4gICAgICAgIGdsb2JhbENvbnRleHQgPSBjb250ZXh0O1xuICAgIH1cblxuICAgIGZpbGVOYW1lcy5mb3JFYWNoKChmaWxlTmFtZSkgPT4ge1xuICAgICAgICBsZXQgc291cmNlRmlsZTogdHMuTm9kZTtcbiAgICAgICAgbGV0IHNvdXJjZUZpbGVOYW1lOiBzdHJpbmc7XG5cbiAgICAgICAgY29uc3QgZmlsZU5hbWVBbHRlcm5hdGl2ZXMgPSBbXTtcblxuICAgICAgICBpZiAoIWZpbGVOYW1lLmVuZHNXaXRoKFwiLnRzXCIpICYmICFmaWxlTmFtZS5lbmRzV2l0aChcIi5qc1wiKSkge1xuICAgICAgICAgICAgZmlsZU5hbWVBbHRlcm5hdGl2ZXMucHVzaChgJHtmaWxlTmFtZX0udHNgKTtcbiAgICAgICAgICAgIGZpbGVOYW1lQWx0ZXJuYXRpdmVzLnB1c2goYCR7ZmlsZU5hbWV9L2luZGV4LnRzYCk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZpbGVOYW1lQWx0ZXJuYXRpdmVzLnB1c2goZmlsZU5hbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmaWxlTmFtZUFsdGVybmF0aXZlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzb3VyY2VGaWxlTmFtZSA9IHBhdGgucmVzb2x2ZShmaWxlTmFtZUFsdGVybmF0aXZlc1tpXSk7XG5cbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkRmlsZXNbc291cmNlRmlsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHNvdXJjZUZpbGUgPSB0cy5jcmVhdGVTb3VyY2VGaWxlKFxuICAgICAgICAgICAgICAgICAgICBzb3VyY2VGaWxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgcmVhZEZpbGVTeW5jKHNvdXJjZUZpbGVOYW1lKS50b1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICB0cy5TY3JpcHRUYXJnZXQuTGF0ZXN0LFxuICAgICAgICAgICAgICAgICAgICB0cnVlXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIHBhcnNlZEZpbGVzW3NvdXJjZUZpbGVOYW1lXSA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZyhgJHtmaWxlTmFtZUFsdGVybmF0aXZlc1tpXX0gPT4gJHtlLm1lc3NhZ2V9YCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc291cmNlRmlsZSkge1xuICAgICAgICAgICAgaW5zcGVjdE5vZGUoc291cmNlRmlsZSwgY29udGV4dCwgZGVjb3JhdG9yTmFtZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBjb250ZXh0LmdldFN0cnVjdHVyZXMoKTtcbn0iXX0=